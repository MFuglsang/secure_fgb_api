{"version":3,"sources":["../../../../../src/ts/generic/geometry.ts"],"sourcesContent":["import type * as flatbuffers from 'flatbuffers';\nimport type { GeometryLayout } from 'ol/geom/Geometry.js';\nimport { Geometry } from '../flat-geobuf/geometry.js';\nimport { GeometryType } from '../flat-geobuf/geometry-type.js';\n\nexport interface IParsedGeometry {\n    xy: number[];\n    z?: number[];\n    m?: number[];\n    ends: number[];\n    parts: IParsedGeometry[];\n    type: GeometryType;\n}\n\nexport interface ISimpleGeometry {\n    getFlatCoordinates?(): number[];\n    getType(): string;\n    getLayout?: () => GeometryLayout;\n}\n\nexport interface IPolygon extends ISimpleGeometry {\n    getEnds(): number[];\n}\n\nexport interface IMultiLineString extends ISimpleGeometry {\n    getEnds(): number[];\n}\n\nexport interface IMultiPolygon extends ISimpleGeometry {\n    getEndss(): number[][];\n    getPolygons(): IPolygon[];\n}\n\nexport type ICreateGeometry = (geometry: Geometry | null, type: GeometryType) => ISimpleGeometry | undefined;\n\nexport function buildGeometry(builder: flatbuffers.Builder, parsedGeometry: IParsedGeometry) {\n    const { xy, z, m, ends, parts, type } = parsedGeometry;\n\n    if (parts) {\n        const partOffsets = parts.map((part) => buildGeometry(builder, part));\n        const partsOffset = Geometry.createPartsVector(builder, partOffsets);\n        Geometry.startGeometry(builder);\n        Geometry.addParts(builder, partsOffset);\n        Geometry.addType(builder, type);\n        return Geometry.endGeometry(builder);\n    }\n\n    const xyOffset = Geometry.createXyVector(builder, xy);\n    let zOffset: number | undefined;\n    if (z) zOffset = Geometry.createZVector(builder, z);\n\n    let mOffset: number | undefined;\n    if (m) mOffset = Geometry.createMVector(builder, m);\n\n    let endsOffset: number | undefined;\n    if (ends) endsOffset = Geometry.createEndsVector(builder, ends);\n\n    Geometry.startGeometry(builder);\n    if (endsOffset) Geometry.addEnds(builder, endsOffset);\n    Geometry.addXy(builder, xyOffset);\n    if (zOffset) Geometry.addZ(builder, zOffset);\n    if (mOffset) Geometry.addM(builder, mOffset);\n    Geometry.addType(builder, type);\n    return Geometry.endGeometry(builder);\n}\n\nexport function flat(a: number[] | number[][], xy: number[], z: number[]): number[] | undefined {\n    if (a.length === 0) return;\n    if (Array.isArray(a[0])) {\n        for (const sa of a as number[][]) flat(sa, xy, z);\n    } else {\n        if (a.length === 2) xy.push(...(a as number[]));\n        else {\n            xy.push(a[0], (a as number[])[1]);\n            z.push((a as number[])[2]);\n        }\n    }\n}\n\nfunction deinterleaveZ(flatCoordinates: number[]): [number[], number[]] {\n    const cLength = flatCoordinates.length / 3;\n    const xy = new Array(cLength * 2);\n    const z = new Array(cLength);\n    for (let i = 0, j = 0; i < flatCoordinates.length; i += 3, j++) {\n        xy[j * 2] = flatCoordinates[i];\n        xy[j * 2 + 1] = flatCoordinates[i + 1];\n        z[j] = flatCoordinates[i + 2];\n    }\n    return [xy, z];\n}\n\nfunction deinterleaveZM(flatCoordinates: number[]): [number[], number[], number[]] {\n    const cLength = flatCoordinates.length / 4;\n    const xy = new Array(cLength * 2);\n    const z = new Array(cLength);\n    const m = new Array(cLength);\n    for (let i = 0, j = 0; i < flatCoordinates.length; i += 4, j++) {\n        xy[j * 2] = flatCoordinates[i];\n        xy[j * 2 + 1] = flatCoordinates[i + 1];\n        z[j] = flatCoordinates[i + 2];\n        m[j] = flatCoordinates[i + 3];\n    }\n\n    return [xy, z, m];\n}\n\nexport function parseGeometry(geometry: ISimpleGeometry, headerGeomType: GeometryType): IParsedGeometry {\n    let flatCoordinates: number[] | undefined;\n    let xy: number[] | undefined;\n    let z: number[] | undefined;\n    let m: number[] | undefined;\n    let ends: number[] | undefined;\n    let parts: IParsedGeometry[] | undefined;\n\n    let type = headerGeomType;\n    if (type === GeometryType.Unknown) {\n        type = toGeometryType(geometry.getType());\n    }\n\n    let flatEnds: number[] | undefined;\n    if (type === GeometryType.MultiLineString) {\n        if (geometry.getFlatCoordinates) flatCoordinates = geometry.getFlatCoordinates();\n        flatEnds = (geometry as IMultiLineString).getEnds();\n    } else if (type === GeometryType.Polygon) {\n        if (geometry.getFlatCoordinates) flatCoordinates = geometry.getFlatCoordinates();\n        flatEnds = (geometry as IPolygon).getEnds();\n    } else if (type === GeometryType.MultiPolygon) {\n        const mp = geometry as IMultiPolygon;\n        parts = mp.getPolygons().map((p) => parseGeometry(p, GeometryType.Polygon));\n    } else {\n        if (geometry.getFlatCoordinates) flatCoordinates = geometry.getFlatCoordinates();\n    }\n\n    const layout = geometry.getLayout?.() ?? 'XY';\n    if (flatCoordinates) {\n        if (layout === 'XY') {\n            xy = flatCoordinates;\n        } else if (layout === 'XYZ') {\n            [xy, z] = deinterleaveZ(flatCoordinates);\n        } else if (layout === 'XYM') {\n            [xy, m] = deinterleaveZ(flatCoordinates);\n        } else if (layout === 'XYZM') {\n            [xy, z, m] = deinterleaveZM(flatCoordinates);\n        }\n    }\n\n    if (flatEnds) {\n        let endDivision = 2;\n        if (layout === 'XYZ' || layout === 'XYM') endDivision = 3;\n        else if (layout === 'XYZM') endDivision = 4;\n        ends = flatEnds.map((e) => e / endDivision);\n    }\n\n    return {\n        xy,\n        z,\n        m,\n        ends,\n        type,\n        parts,\n    } as IParsedGeometry;\n}\n\nexport function pairFlatCoordinates(xy: Float64Array, z?: Float64Array): number[][] {\n    const newArray: number[][] = [];\n    for (let i = 0; i < xy.length; i += 2) {\n        const a = [xy[i], xy[i + 1]];\n        if (z) a.push(z[i >> 1]);\n        newArray.push(a);\n    }\n    return newArray;\n}\n\nexport function toGeometryType(name?: string): GeometryType {\n    if (!name) return GeometryType.Unknown;\n    const type: GeometryType = (GeometryType as never)[name];\n    return type;\n}\n"],"names":["Geometry","GeometryType","buildGeometry","builder","parsedGeometry","zOffset","mOffset","endsOffset","xy","z","m","ends","parts","type","partOffsets","map","part","partsOffset","createPartsVector","startGeometry","addParts","addType","endGeometry","xyOffset","createXyVector","createZVector","createMVector","createEndsVector","addEnds","addXy","addZ","addM","flat","a","length","Array","isArray","sa","push","deinterleaveZ","flatCoordinates","cLength","i","j","parseGeometry","geometry","headerGeomType","flatEnds","Unknown","toGeometryType","getType","MultiLineString","Polygon","getFlatCoordinates","getEnds","MultiPolygon","mp","getPolygons","p","layout","getLayout","deinterleaveZM","endDivision","e","pairFlatCoordinates","newArray","name"],"mappings":"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"}