import{Geometry as e}from"../flat-geobuf/geometry.js";import{GeometryType as t}from"../flat-geobuf/geometry-type.js";export function buildGeometry(t,r){let o,n,a,{xy:l,z:y,m:d,ends:i,parts:u,type:f}=r;if(u){let r=u.map(e=>buildGeometry(t,e)),o=e.createPartsVector(t,r);return e.startGeometry(t),e.addParts(t,o),e.addType(t,f),e.endGeometry(t)}let g=e.createXyVector(t,l);return y&&(o=e.createZVector(t,y)),d&&(n=e.createMVector(t,d)),i&&(a=e.createEndsVector(t,i)),e.startGeometry(t),a&&e.addEnds(t,a),e.addXy(t,g),o&&e.addZ(t,o),n&&e.addM(t,n),e.addType(t,f),e.endGeometry(t)}export function flat(e,t,r){if(0!==e.length)if(Array.isArray(e[0]))for(let o of e)flat(o,t,r);else 2===e.length?t.push(...e):(t.push(e[0],e[1]),r.push(e[2]))}function r(e){let t=e.length/3,r=Array(2*t),o=Array(t);for(let t=0,n=0;t<e.length;t+=3,n++)r[2*n]=e[t],r[2*n+1]=e[t+1],o[n]=e[t+2];return[r,o]}export function parseGeometry(e,o){let n,a,l,y,d,i,u,f=o;f===t.Unknown&&(f=toGeometryType(e.getType())),f===t.MultiLineString||f===t.Polygon?(e.getFlatCoordinates&&(n=e.getFlatCoordinates()),u=e.getEnds()):f===t.MultiPolygon?i=e.getPolygons().map(e=>parseGeometry(e,t.Polygon)):e.getFlatCoordinates&&(n=e.getFlatCoordinates());let g=e.getLayout?.()??"XY";if(n&&("XY"===g?a=n:"XYZ"===g?[a,l]=r(n):"XYM"===g?[a,y]=r(n):"XYZM"===g&&([a,l,y]=function(e){let t=e.length/4,r=Array(2*t),o=Array(t),n=Array(t);for(let t=0,a=0;t<e.length;t+=4,a++)r[2*a]=e[t],r[2*a+1]=e[t+1],o[a]=e[t+2],n[a]=e[t+3];return[r,o,n]}(n))),u){let e=2;"XYZ"===g||"XYM"===g?e=3:"XYZM"===g&&(e=4),d=u.map(t=>t/e)}return{xy:a,z:l,m:y,ends:d,type:f,parts:i}}export function pairFlatCoordinates(e,t){let r=[];for(let o=0;o<e.length;o+=2){let n=[e[o],e[o+1]];t&&n.push(t[o>>1]),r.push(n)}return r}export function toGeometryType(e){return e?t[e]:t.Unknown}
//# sourceMappingURL=geometry.js.map