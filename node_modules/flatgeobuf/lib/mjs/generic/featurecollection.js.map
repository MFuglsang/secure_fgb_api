{"version":3,"sources":["../../../../../src/ts/generic/featurecollection.ts"],"sourcesContent":["import * as flatbuffers from 'flatbuffers';\nimport slice from 'slice-source';\nimport { ArrayReader } from '../array-reader.js';\nimport type { ColumnMeta } from '../column-meta.js';\nimport { magicbytes, SIZE_PREFIX_LEN } from '../constants.js';\nimport { Column } from '../flat-geobuf/column.js';\nimport { ColumnType } from '../flat-geobuf/column-type.js';\nimport { Crs } from '../flat-geobuf/crs.js';\nimport { Feature } from '../flat-geobuf/feature.js';\nimport { Header } from '../flat-geobuf/header.js';\nimport type { HeaderMetaFn } from '../generic.js';\nimport type { HeaderMeta } from '../header-meta.js';\nimport { fromByteBuffer } from '../header-meta.js';\nimport { HttpReader } from '../http-reader.js';\nimport { calcTreeSize, type Rect } from '../packedrtree.js';\nimport { buildFeature, type IFeature, type IProperties } from './feature.js';\nimport { parseGeometry } from './geometry.js';\nimport { inferGeometryType } from './header.js';\n\nexport type FromFeatureFn = (id: number, feature: Feature, header: HeaderMeta) => IFeature;\ntype ReadFn = (size: number, purpose: string) => Promise<ArrayBuffer | Uint8Array>;\n\n/**\n * Serialize generic features to FlatGeobuf\n * @param features\n */\nexport function serialize(features: IFeature[]): Uint8Array {\n    const headerMeta = introspectHeaderMeta(features);\n    const header = buildHeader(headerMeta);\n    const featureBuffers: Uint8Array[] = features.map((f) => {\n        if (!f.getGeometry) throw new Error('Missing getGeometry implementation');\n        if (!f.getProperties) throw new Error('Missing getProperties implementation');\n        return buildFeature(parseGeometry(f.getGeometry(), headerMeta.geometryType), f.getProperties(), headerMeta);\n    });\n    const featuresLength = featureBuffers.map((f) => f.length).reduce((a, b) => a + b);\n    const uint8 = new Uint8Array(magicbytes.length + header.length + featuresLength);\n    uint8.set(header, magicbytes.length);\n    let offset = magicbytes.length + header.length;\n    for (const feature of featureBuffers) {\n        uint8.set(feature, offset);\n        offset += feature.length;\n    }\n    uint8.set(magicbytes);\n    return uint8;\n}\n\nexport async function* deserialize(\n    bytes: Uint8Array,\n    fromFeature: FromFeatureFn,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n): AsyncGenerator<IFeature> {\n    if (!bytes.subarray(0, 3).every((v, i) => magicbytes[i] === v)) throw new Error('Not a FlatGeobuf file');\n\n    if (rect) {\n        const reader = ArrayReader.open(bytes);\n        for await (const feature of reader.selectBbox(rect)) {\n            yield fromFeature(feature.id, feature.feature, reader.header);\n        }\n        return;\n    }\n\n    const bb = new flatbuffers.ByteBuffer(bytes);\n    const headerLength = bb.readUint32(magicbytes.length);\n    bb.setPosition(magicbytes.length + SIZE_PREFIX_LEN);\n\n    const headerMeta = fromByteBuffer(bb);\n    if (headerMetaFn) headerMetaFn(headerMeta);\n\n    let offset = magicbytes.length + SIZE_PREFIX_LEN + headerLength;\n\n    const { indexNodeSize, featuresCount } = headerMeta;\n    if (indexNodeSize > 0) offset += calcTreeSize(featuresCount, indexNodeSize);\n\n    let id = 0;\n    while (offset < bb.capacity()) {\n        const featureLength = bb.readUint32(offset);\n        bb.setPosition(offset + SIZE_PREFIX_LEN);\n        const feature = Feature.getRootAsFeature(bb);\n        yield fromFeature(id++, feature, headerMeta);\n        offset += SIZE_PREFIX_LEN + featureLength;\n    }\n}\n\nexport async function* deserializeStream(\n    stream: ReadableStream,\n    fromFeature: FromFeatureFn,\n    headerMetaFn?: HeaderMetaFn,\n): AsyncGenerator<IFeature> {\n    const reader = slice(stream);\n    const read: ReadFn = async (size) => await reader.slice(size);\n\n    let bytes = new Uint8Array(await read(8, 'magic bytes'));\n    if (!bytes.subarray(0, 3).every((v, i) => magicbytes[i] === v)) throw new Error('Not a FlatGeobuf file');\n    bytes = new Uint8Array(await read(4, 'header length'));\n    let bb = new flatbuffers.ByteBuffer(bytes);\n    const headerLength = bb.readUint32(0);\n    bytes = new Uint8Array(await read(headerLength, 'header data'));\n    bb = new flatbuffers.ByteBuffer(bytes);\n\n    const headerMeta = fromByteBuffer(bb);\n    if (headerMetaFn) headerMetaFn(headerMeta);\n\n    const { indexNodeSize, featuresCount } = headerMeta;\n    if (indexNodeSize > 0) {\n        const treeSize = calcTreeSize(featuresCount, indexNodeSize);\n        await read(treeSize, 'entire index, w/o rect');\n    }\n    let feature: IFeature | undefined;\n    let id = 0;\n    while ((feature = await readFeature(read, headerMeta, fromFeature, id++))) yield feature;\n}\n\nexport async function* deserializeFiltered(\n    url: string,\n    rect: Rect,\n    fromFeature: FromFeatureFn,\n    headerMetaFn?: HeaderMetaFn,\n    nocache = false,\n    headers: HeadersInit = {},\n): AsyncGenerator<IFeature> {\n    const reader = await HttpReader.open(url, nocache, headers);\n    console.debug('opened reader');\n    if (headerMetaFn) headerMetaFn(reader.header);\n    for await (const feature of reader.selectBbox(rect)) yield fromFeature(feature.id, feature.feature, reader.header);\n}\n\nasync function readFeature(\n    read: ReadFn,\n    headerMeta: HeaderMeta,\n    fromFeature: FromFeatureFn,\n    id: number,\n): Promise<IFeature | undefined> {\n    let bytes = new Uint8Array(await read(4, 'feature length'));\n    if (bytes.byteLength === 0) return;\n    let bb = new flatbuffers.ByteBuffer(bytes);\n    const featureLength = bb.readUint32(0);\n    bytes = new Uint8Array(await read(featureLength, 'feature data'));\n    const bytesAligned = new Uint8Array(featureLength + 4);\n    bytesAligned.set(bytes, 4);\n    bb = new flatbuffers.ByteBuffer(bytesAligned);\n    bb.setPosition(SIZE_PREFIX_LEN);\n    const feature = Feature.getRootAsFeature(bb);\n    return fromFeature(id, feature, headerMeta);\n}\n\nfunction buildColumn(builder: flatbuffers.Builder, column: ColumnMeta): number {\n    const nameOffset = builder.createString(column.name);\n    Column.startColumn(builder);\n    Column.addName(builder, nameOffset);\n    Column.addType(builder, column.type);\n    return Column.endColumn(builder);\n}\n\nexport function buildHeader(header: HeaderMeta, crsCode = 0): Uint8Array {\n    const builder = new flatbuffers.Builder();\n\n    let columnOffsets = 0;\n    if (header.columns)\n        columnOffsets = Header.createColumnsVector(\n            builder,\n            header.columns.map((c) => buildColumn(builder, c)),\n        );\n\n    const nameOffset = builder.createString('L1');\n\n    let crsOffset: flatbuffers.Offset | undefined;\n    if (crsCode) {\n        Crs.startCrs(builder);\n        Crs.addCode(builder, crsCode);\n        crsOffset = Crs.endCrs(builder);\n    }\n    Header.startHeader(builder);\n    if (crsOffset) Header.addCrs(builder, crsOffset);\n    Header.addFeaturesCount(builder, BigInt(header.featuresCount));\n    Header.addGeometryType(builder, header.geometryType);\n    Header.addIndexNodeSize(builder, 0);\n    if (columnOffsets) Header.addColumns(builder, columnOffsets);\n    Header.addName(builder, nameOffset);\n    const offset = Header.endHeader(builder);\n    builder.finishSizePrefixed(offset);\n    return builder.asUint8Array() as Uint8Array;\n}\n\nfunction valueToType(value: boolean | number | string | Uint8Array | undefined): ColumnType {\n    if (typeof value === 'boolean') return ColumnType.Bool;\n    if (typeof value === 'number') {\n        if (value % 1 === 0) return ColumnType.Int;\n        return ColumnType.Double;\n    }\n    if (typeof value === 'string') return ColumnType.String;\n    if (value === null) return ColumnType.String;\n    if (value instanceof Uint8Array) return ColumnType.Binary;\n    if (typeof value === 'object') return ColumnType.Json;\n    throw new Error(`Unknown type (value '${value}')`);\n}\n\nexport function mapColumn(properties: IProperties, k: string): ColumnMeta {\n    return {\n        name: k,\n        type: valueToType(properties[k]),\n        title: null,\n        description: null,\n        width: -1,\n        precision: -1,\n        scale: -1,\n        nullable: true,\n        unique: false,\n        primary_key: false,\n    };\n}\n\nfunction introspectHeaderMeta(features: IFeature[]): HeaderMeta {\n    const sampleFeature = features[0];\n    const properties = sampleFeature.getProperties ? sampleFeature.getProperties() : {};\n\n    let columns: ColumnMeta[] | null = null;\n    if (properties)\n        columns = Object.keys(properties)\n            .filter((key) => key !== 'geometry')\n            .map((k) => mapColumn(properties, k));\n\n    const geometryType = inferGeometryType(features);\n    const headerMeta: HeaderMeta = {\n        geometryType,\n        columns,\n        envelope: null,\n        featuresCount: features.length,\n        indexNodeSize: 0,\n        crs: null,\n        title: null,\n        description: null,\n        metadata: null,\n    };\n    return headerMeta;\n}\n"],"names":["flatbuffers","slice","ArrayReader","magicbytes","SIZE_PREFIX_LEN","Column","ColumnType","Crs","Feature","Header","fromByteBuffer","HttpReader","calcTreeSize","buildFeature","parseGeometry","inferGeometryType","serialize","features","headerMeta","introspectHeaderMeta","sampleFeature","properties","getProperties","columns","Object","keys","filter","key","map","k","mapColumn","geometryType","envelope","featuresCount","length","indexNodeSize","crs","title","description","metadata","header","buildHeader","featureBuffers","f","getGeometry","Error","featuresLength","reduce","a","b","uint8","Uint8Array","set","offset","feature","deserialize","bytes","fromFeature","rect","headerMetaFn","subarray","every","v","i","reader","open","selectBbox","id","bb","ByteBuffer","headerLength","readUint32","setPosition","capacity","featureLength","getRootAsFeature","deserializeStream","stream","read","size","treeSize","readFeature","deserializeFiltered","url","nocache","headers","byteLength","bytesAligned","crsCode","crsOffset","builder","Builder","columnOffsets","createColumnsVector","c","buildColumn","column","nameOffset","createString","name","startColumn","addName","addType","type","endColumn","startCrs","addCode","endCrs","startHeader","addCrs","addFeaturesCount","BigInt","addGeometryType","addIndexNodeSize","addColumns","endHeader","finishSizePrefixed","asUint8Array","valueToType","value","Bool","Int","Double","String","Binary","Json","width","precision","scale","nullable","unique","primary_key"],"mappings":"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"}