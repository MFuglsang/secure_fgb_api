import*as e from"flatbuffers";import t from"slice-source";import{ArrayReader as r}from"../array-reader.js";import{magicbytes as n,SIZE_PREFIX_LEN as o}from"../constants.js";import{Column as a}from"../flat-geobuf/column.js";import{ColumnType as i}from"../flat-geobuf/column-type.js";import{Crs as l}from"../flat-geobuf/crs.js";import{Feature as f}from"../flat-geobuf/feature.js";import{Header as u}from"../flat-geobuf/header.js";import{fromByteBuffer as s}from"../header-meta.js";import{HttpReader as m}from"../http-reader.js";import{calcTreeSize as d}from"../packedrtree.js";import{buildFeature as p}from"./feature.js";import{parseGeometry as y}from"./geometry.js";import{inferGeometryType as c}from"./header.js";export function serialize(e){let t=function(e){let t=e[0],r=t.getProperties?t.getProperties():{},n=null;return r&&(n=Object.keys(r).filter(e=>"geometry"!==e).map(e=>mapColumn(r,e))),{geometryType:c(e),columns:n,envelope:null,featuresCount:e.length,indexNodeSize:0,crs:null,title:null,description:null,metadata:null}}(e),r=buildHeader(t),o=e.map(e=>{if(!e.getGeometry)throw Error("Missing getGeometry implementation");if(!e.getProperties)throw Error("Missing getProperties implementation");return p(y(e.getGeometry(),t.geometryType),e.getProperties(),t)}),a=o.map(e=>e.length).reduce((e,t)=>e+t),i=new Uint8Array(n.length+r.length+a);i.set(r,n.length);let l=n.length+r.length;for(let e of o)i.set(e,l),l+=e.length;return i.set(n),i}export async function*deserialize(t,a,i,l){if(!t.subarray(0,3).every((e,t)=>n[t]===e))throw Error("Not a FlatGeobuf file");if(i){let e=r.open(t);for await(let t of e.selectBbox(i))yield a(t.id,t.feature,e.header);return}let u=new e.ByteBuffer(t),m=u.readUint32(n.length);u.setPosition(n.length+o);let p=s(u);l&&l(p);let y=n.length+o+m,{indexNodeSize:c,featuresCount:g}=p;c>0&&(y+=d(g,c));let w=0;for(;y<u.capacity();){let e=u.readUint32(y);u.setPosition(y+o);let t=f.getRootAsFeature(u);yield a(w++,t,p),y+=o+e}}export async function*deserializeStream(r,o,a){let i,l=t(r),f=async e=>await l.slice(e),u=new Uint8Array(await f(8,"magic bytes"));if(!u.subarray(0,3).every((e,t)=>n[t]===e))throw Error("Not a FlatGeobuf file");u=new Uint8Array(await f(4,"header length"));let m=new e.ByteBuffer(u),p=m.readUint32(0);u=new Uint8Array(await f(p,"header data"));let y=s(m=new e.ByteBuffer(u));a&&a(y);let{indexNodeSize:c,featuresCount:w}=y;if(c>0){let e=d(w,c);await f(e,"entire index, w/o rect")}let h=0;for(;i=await g(f,y,o,h++);)yield i}export async function*deserializeFiltered(e,t,r,n,o=!1,a={}){let i=await m.open(e,o,a);for await(let e of(n&&n(i.header),i.selectBbox(t)))yield r(e.id,e.feature,i.header)}async function g(t,r,n,a){let i=new Uint8Array(await t(4,"feature length"));if(0===i.byteLength)return;let l=new e.ByteBuffer(i),u=l.readUint32(0);i=new Uint8Array(await t(u,"feature data"));let s=new Uint8Array(u+4);return s.set(i,4),(l=new e.ByteBuffer(s)).setPosition(o),n(a,f.getRootAsFeature(l),r)}export function buildHeader(t,r=0){let n,o=new e.Builder,i=0;t.columns&&(i=u.createColumnsVector(o,t.columns.map(e=>(function(e,t){let r=e.createString(t.name);return a.startColumn(e),a.addName(e,r),a.addType(e,t.type),a.endColumn(e)})(o,e))));let f=o.createString("L1");r&&(l.startCrs(o),l.addCode(o,r),n=l.endCrs(o)),u.startHeader(o),n&&u.addCrs(o,n),u.addFeaturesCount(o,BigInt(t.featuresCount)),u.addGeometryType(o,t.geometryType),u.addIndexNodeSize(o,0),i&&u.addColumns(o,i),u.addName(o,f);let s=u.endHeader(o);return o.finishSizePrefixed(s),o.asUint8Array()}export function mapColumn(e,t){return{name:t,type:function(e){if("boolean"==typeof e)return i.Bool;if("number"==typeof e)return e%1==0?i.Int:i.Double;if("string"==typeof e||null===e)return i.String;if(e instanceof Uint8Array)return i.Binary;if("object"==typeof e)return i.Json;throw Error(`Unknown type (value '${e}')`)}(e[t]),title:null,description:null,width:-1,precision:-1,scale:-1,nullable:!0,unique:!1,primary_key:!1}}
//# sourceMappingURL=featurecollection.js.map