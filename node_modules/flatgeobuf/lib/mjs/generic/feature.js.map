{"version":3,"sources":["../../../../../src/ts/generic/feature.ts"],"sourcesContent":["import * as flatbuffers from 'flatbuffers';\n\nimport type { ColumnMeta } from '../column-meta.js';\nimport { ColumnType } from '../flat-geobuf/column-type.js';\nimport { Feature } from '../flat-geobuf/feature.js';\nimport type { HeaderMeta } from '../header-meta.js';\nimport { buildGeometry, type ICreateGeometry, type IParsedGeometry, type ISimpleGeometry } from './geometry.js';\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nexport interface IProperties {\n    [key: string]: boolean | number | string | Uint8Array | undefined;\n}\n\nexport interface IFeature {\n    getGeometry?(): ISimpleGeometry;\n    getId?(): number;\n    getProperties?(): IProperties;\n    setProperties?(properties: IProperties): void;\n}\n\nexport type ICreateFeature = (\n    id: number,\n    geometry?: ISimpleGeometry,\n    properties?: Record<string, string | number | boolean | Uint8Array | undefined>,\n) => IFeature;\n\nexport function fromFeature(\n    id: number,\n    feature: Feature,\n    header: HeaderMeta,\n    createGeometry: ICreateGeometry,\n    createFeature: ICreateFeature,\n): IFeature {\n    const columns = header.columns;\n    const geometry = feature.geometry();\n    const simpleGeometry = createGeometry(geometry, header.geometryType);\n    const properties = parseProperties(feature, columns as ColumnMeta[]);\n    return createFeature(id, simpleGeometry, properties);\n}\n\nexport function buildFeature(geometry: IParsedGeometry, properties: IProperties, header: HeaderMeta): Uint8Array {\n    const columns = header.columns;\n    const builder = new flatbuffers.Builder();\n\n    let offset = 0;\n    let capacity = 1024;\n    let bytes = new Uint8Array(capacity);\n    let view = new DataView(bytes.buffer);\n\n    const prep = (size: number) => {\n        if (offset + size < capacity) return;\n        capacity = Math.max(capacity + size, capacity * 2);\n        const newBytes = new Uint8Array(capacity);\n        newBytes.set(bytes);\n        bytes = newBytes;\n        view = new DataView(bytes.buffer);\n    };\n\n    if (columns) {\n        for (let i = 0; i < columns.length; i++) {\n            const column = columns[i];\n            const value = properties[column.name];\n            if (value === null) continue;\n            prep(2);\n            view.setUint16(offset, i, true);\n            offset += 2;\n            switch (column.type) {\n                case ColumnType.Bool:\n                    prep(1);\n                    view.setUint8(offset, value as number);\n                    offset += 1;\n                    break;\n                case ColumnType.Short:\n                    prep(2);\n                    view.setInt16(offset, value as number, true);\n                    offset += 2;\n                    break;\n                case ColumnType.UShort:\n                    prep(2);\n                    view.setUint16(offset, value as number, true);\n                    offset += 2;\n                    break;\n                case ColumnType.Int:\n                    prep(4);\n                    view.setInt32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.UInt:\n                    prep(4);\n                    view.setUint32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.Long:\n                    prep(8);\n                    view.setBigInt64(offset, BigInt(value as number), true);\n                    offset += 8;\n                    break;\n                case ColumnType.Float:\n                    prep(4);\n                    view.setFloat32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.Double:\n                    prep(8);\n                    view.setFloat64(offset, value as number, true);\n                    offset += 8;\n                    break;\n                case ColumnType.DateTime:\n                case ColumnType.String: {\n                    const str = textEncoder.encode(value as string);\n                    prep(4);\n                    view.setUint32(offset, str.length, true);\n                    offset += 4;\n                    prep(str.length);\n                    bytes.set(str, offset);\n                    offset += str.length;\n                    break;\n                }\n                case ColumnType.Json: {\n                    const str = textEncoder.encode(JSON.stringify(value));\n                    prep(4);\n                    view.setUint32(offset, str.length, true);\n                    offset += 4;\n                    prep(str.length);\n                    bytes.set(str, offset);\n                    offset += str.length;\n                    break;\n                }\n                case ColumnType.Binary: {\n                    prep(4);\n                    const blob = value as Uint8Array;\n                    view.setUint32(offset, blob.length, true);\n                    offset += 4;\n                    prep(blob.length);\n                    bytes.set(blob, offset);\n                    offset += blob.length;\n                    break;\n                }\n                default:\n                    throw new Error(`Unknown type ${column.type}`);\n            }\n        }\n    }\n\n    let propertiesOffset = 0;\n    if (offset > 0) propertiesOffset = Feature.createPropertiesVector(builder, bytes.slice(0, offset));\n\n    const geometryOffset = buildGeometry(builder, geometry);\n    Feature.startFeature(builder);\n    Feature.addGeometry(builder, geometryOffset);\n    if (propertiesOffset) Feature.addProperties(builder, propertiesOffset);\n    const featureOffset = Feature.endFeature(builder);\n    builder.finishSizePrefixed(featureOffset);\n    return builder.asUint8Array() as Uint8Array;\n}\n\n/**\n * Parse properties from a FlatGeobuf feature.\n * @param feature Feature to parse the properties from.\n * @param columns Column metadata used as property definition.\n */\nexport function parseProperties(feature: Feature, columns?: ColumnMeta[] | null): IProperties {\n    const properties: IProperties = {};\n    if (!columns || columns.length === 0) return properties;\n    const array = feature.propertiesArray();\n    if (!array) return properties;\n    const view = new DataView(array.buffer, array.byteOffset);\n    const length = feature.propertiesLength();\n    let offset = 0;\n    while (offset < length) {\n        const i = view.getUint16(offset, true);\n        offset += 2;\n        const column = columns[i];\n        const name = column.name;\n        switch (column.type) {\n            case ColumnType.Bool: {\n                properties[name] = !!view.getUint8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.Byte: {\n                properties[name] = view.getInt8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.UByte: {\n                properties[name] = view.getUint8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.Short: {\n                properties[name] = view.getInt16(offset, true);\n                offset += 2;\n                break;\n            }\n            case ColumnType.UShort: {\n                properties[name] = view.getUint16(offset, true);\n                offset += 2;\n                break;\n            }\n            case ColumnType.Int: {\n                properties[name] = view.getInt32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.UInt: {\n                properties[name] = view.getUint32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.Long: {\n                properties[name] = Number(view.getBigInt64(offset, true));\n                offset += 8;\n                break;\n            }\n            case ColumnType.ULong: {\n                properties[name] = Number(view.getBigUint64(offset, true));\n                offset += 8;\n                break;\n            }\n            case ColumnType.Float: {\n                properties[name] = view.getFloat32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.Double: {\n                properties[name] = view.getFloat64(offset, true);\n                offset += 8;\n                break;\n            }\n            case ColumnType.DateTime:\n            case ColumnType.String: {\n                const length = view.getUint32(offset, true);\n                offset += 4;\n                properties[name] = textDecoder.decode(array.subarray(offset, offset + length));\n                offset += length;\n                break;\n            }\n            case ColumnType.Json: {\n                const length = view.getUint32(offset, true);\n                offset += 4;\n                const str = textDecoder.decode(array.subarray(offset, offset + length));\n                properties[name] = JSON.parse(str);\n                offset += length;\n                break;\n            }\n            case ColumnType.Binary: {\n                const length = view.getUint32(offset, true);\n                offset += 4;\n                properties[name] = array.subarray(offset, offset + length);\n                offset += length;\n                break;\n            }\n            default:\n                throw new Error(`Unknown type ${column.type}`);\n        }\n    }\n    return properties;\n}\n"],"names":["flatbuffers","ColumnType","Feature","buildGeometry","textEncoder","TextEncoder","textDecoder","TextDecoder","fromFeature","id","feature","header","createGeometry","createFeature","columns","geometry","geometryType","parseProperties","buildFeature","properties","builder","Builder","offset","capacity","bytes","Uint8Array","view","DataView","buffer","prep","size","newBytes","Math","max","set","i","length","column","value","name","setUint16","type","Bool","setUint8","Short","setInt16","UShort","Int","setInt32","UInt","setUint32","Long","setBigInt64","BigInt","Float","setFloat32","Double","setFloat64","DateTime","String","str","encode","Json","JSON","stringify","Binary","blob","Error","propertiesOffset","createPropertiesVector","slice","geometryOffset","startFeature","addGeometry","addProperties","featureOffset","endFeature","finishSizePrefixed","asUint8Array","array","propertiesArray","byteOffset","propertiesLength","getUint16","getUint8","Byte","getInt8","UByte","getInt16","getInt32","getUint32","Number","getBigInt64","ULong","getBigUint64","getFloat32","getFloat64","decode","subarray","parse"],"mappings":"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"}