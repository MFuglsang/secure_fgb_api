{"version":3,"sources":["../../../../src/ts/packedrtree.ts"],"sourcesContent":["import Config from './config.js';\n\nexport const NODE_ITEM_BYTE_LEN: number = 8 * 4 + 8;\n/**\n * @deprecated Use `NODE_ITEM_BYTE_LEN` instead.\n */\nexport const NODE_ITEM_LEN = NODE_ITEM_BYTE_LEN;\n\n// default branching factor of a node in the rtree\n//\n// actual value will be specified in the header but\n// this can be useful for having reasonably sized guesses for fetch-sizes when\n// streaming results\nexport const DEFAULT_NODE_SIZE = 16;\n\nexport interface Rect {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nexport function calcTreeSize(numItems: number, nodeSize: number): number {\n    nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    let n = numItems;\n    let numNodes = n;\n    do {\n        n = Math.ceil(n / nodeSize);\n        numNodes += n;\n    } while (n !== 1);\n    return numNodes * NODE_ITEM_BYTE_LEN;\n}\n\n/**\n * returns [levelOffset, numNodes] for each level\n */\nexport function generateLevelBounds(numItems: number, nodeSize: number): Array<[number, number]> {\n    if (nodeSize < 2) throw new Error('Node size must be at least 2');\n    if (numItems === 0) throw new Error('Number of items must be greater than 0');\n\n    // number of nodes per level in bottom-up order\n    let n = numItems;\n    let numNodes = n;\n    const levelNumNodes = [n];\n    do {\n        n = Math.ceil(n / nodeSize);\n        numNodes += n;\n        levelNumNodes.push(n);\n    } while (n !== 1);\n\n    // bounds per level in reversed storage order (top-down)\n    const levelOffsets: Array<number> = [];\n    n = numNodes;\n    for (const size of levelNumNodes) {\n        levelOffsets.push(n - size);\n        n -= size;\n    }\n    const levelBounds: Array<[number, number]> = [];\n    for (let i = 0; i < levelNumNodes.length; i++)\n        levelBounds.push([levelOffsets[i], levelOffsets[i] + levelNumNodes[i]]);\n    return levelBounds;\n}\n\ntype ReadNodeFn = (treeOffset: number, size: number) => Promise<ArrayBuffer>;\n\n/**\n * A feature found to be within the bounding box `rect`\n *\n *  (offset, index)\n *  `offset`: Byte offset in feature data section\n *  `index`: feature number\n *  `featureLength`: featureLength, except for the last element\n */\nexport type SearchResult = [number, number, number | null];\n\n/**\n * Yield's a `SearchResult` for each feature within the bounds of `rect`.\n *\n * Every node in the FGB index tree has a bounding rect, all of the nodes children\n * are contained within that bounding rect. The leaf nodes of the tree represent\n * the features of the collection.\n *\n * As we traverse the tree, starting from the root, we'll need to read more data\n * from the index. When we don't already have this range data buffered locally,\n * an HTTP fetch is triggered. For performance, we merge adjacent and nearby\n * request ranges into a single request, reasoning that fetching a few extra\n * bytes is a good tradeoff if it means we can reduce the number of requests.\n */\nexport async function* streamSearch(\n    numItems: number,\n    nodeSize: number,\n    rect: Rect,\n    readNode: ReadNodeFn,\n): AsyncGenerator<SearchResult, void, unknown> {\n    type NodeIdx = number;\n    class NodeRange {\n        _level: number;\n        nodes: [NodeIdx, NodeIdx];\n        constructor(nodes: [NodeIdx, NodeIdx], level: number) {\n            this._level = level;\n            this.nodes = nodes;\n        }\n\n        level(): number {\n            return this._level;\n        }\n\n        startNodeIdx(): NodeIdx {\n            return this.nodes[0];\n        }\n\n        endNodeIdx(): NodeIdx {\n            return this.nodes[1];\n        }\n\n        extendEndNodeIdx(newIdx: number) {\n            console.assert(newIdx > this.nodes[1]);\n            this.nodes[1] = newIdx;\n        }\n\n        toString(): string {\n            return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;\n        }\n    }\n\n    const { minX, minY, maxX, maxY } = rect;\n    console.debug(`tree items: ${numItems}, nodeSize: ${nodeSize}`);\n    const levelBounds = generateLevelBounds(numItems, nodeSize);\n    const firstLeafNodeIdx = levelBounds[0][0];\n\n    const rootNodeRange: NodeRange = (() => {\n        const range: [number, number] = [0, 1];\n        const level = levelBounds.length - 1;\n        return new NodeRange(range, level);\n    })();\n\n    const queue: Array<NodeRange> = [rootNodeRange];\n\n    console.debug(\n        `starting stream search with queue: ${queue}, numItems: ${numItems}, nodeSize: ${nodeSize}, levelBounds: ${levelBounds}`,\n    );\n\n    while (queue.length !== 0) {\n        const nodeRange = queue.shift()!;\n\n        console.debug(`popped node: ${nodeRange}, queueLength: ${queue.length}`);\n\n        const nodeRangeStartIdx = nodeRange.startNodeIdx();\n        const isLeafNode = nodeRangeStartIdx >= firstLeafNodeIdx;\n\n        // find the end index of the node\n        const nodeRangeEndIdx = (() => {\n            const [, levelBound] = levelBounds[nodeRange.level()];\n            const nodeIdx = Math.min(nodeRange.endNodeIdx() + nodeSize, levelBound);\n\n            if (isLeafNode && nodeIdx < levelBound) {\n                // We can infer the length of *this* feature by getting the start of the *next*\n                // feature, so we get an extra node.\n                // This approach doesn't work for the final node in the index,\n                // but in that case we know that the feature runs to the end of the FGB file and\n                // could make an open ended range request to get \"the rest of the data\".\n                return nodeIdx + 1;\n            }\n            return nodeIdx;\n        })();\n\n        const numNodesInRange = nodeRangeEndIdx - nodeRangeStartIdx;\n\n        const buffer = await readNode(nodeRangeStartIdx * NODE_ITEM_BYTE_LEN, numNodesInRange * NODE_ITEM_BYTE_LEN);\n\n        const dataView = new DataView(buffer);\n        for (let nodeIdx = nodeRangeStartIdx; nodeIdx < nodeRangeEndIdx; nodeIdx++) {\n            const nodeIdxInDataView = nodeIdx - nodeRangeStartIdx;\n            const dataViewByteStart = nodeIdxInDataView * NODE_ITEM_BYTE_LEN;\n            if (maxX < dataView.getFloat64(dataViewByteStart + 0, true)) continue; // maxX < nodeMinX\n            if (maxY < dataView.getFloat64(dataViewByteStart + 8, true)) continue; // maxY < nodeMinY\n            if (minX > dataView.getFloat64(dataViewByteStart + 16, true)) continue; // minX > nodeMaxX\n            if (minY > dataView.getFloat64(dataViewByteStart + 24, true)) continue; // minY > nodeMaxY\n\n            // `offset` is:\n            // For leaf nodes: the byte-offset into the feature buffer.\n            // For inner nodes: the node-idx of its first child.\n            const offset = dataView.getBigUint64(dataViewByteStart + 32, true);\n\n            if (isLeafNode) {\n                const featureByteOffset = offset;\n                const featureLength = (() => {\n                    if (nodeIdx < numItems - 1) {\n                        // Since features are tightly packed, we infer the\n                        // length of _this_ feature by measuring to the _next_\n                        // feature's start.\n                        const nextPos = (nodeIdxInDataView + 1) * NODE_ITEM_BYTE_LEN;\n                        // console.debug(`nodeIdx: ${nodeIdx} of ${numItems}, nodeRangeStartIdx: ${nodeRangeStartIdx}, nextPos: ${nextPos}, dataView.byteLength: ${dataView.byteLength}`,);\n                        const nextOffset = dataView.getBigUint64(nextPos + 32, true);\n                        return nextOffset - featureByteOffset;\n                    }\n                    // This is the last feature - there's no \"next\" feature\n                    // to measure to, so we can't know it's length.\n                    return null;\n                })();\n\n                const featureIdx = nodeIdx - firstLeafNodeIdx;\n                yield [Number(featureByteOffset), featureIdx, Number(featureLength)];\n                continue;\n            }\n\n            const firstChildNodeIdx = offset;\n\n            // request up to this many nodes if it means we can eliminate an\n            // extra request\n            const extraRequestThresholdNodes = Config.global.extraRequestThreshold() / NODE_ITEM_BYTE_LEN;\n\n            // Since we're traversing the tree by monotonically increasing byte\n            // offset, the most recently enqueued node range will be the\n            // nearest, and thus presents the best candidate for merging.\n            const nearestNodeRange = queue[queue.length - 1];\n            if (\n                nearestNodeRange !== undefined &&\n                nearestNodeRange.level() === nodeRange.level() - 1 &&\n                firstChildNodeIdx < nearestNodeRange.endNodeIdx() + extraRequestThresholdNodes\n            ) {\n                console.debug(\n                    `Merging \"nodeRange\" request into existing range: ${nearestNodeRange}, newEndNodeIdx: ${nearestNodeRange.endNodeIdx()} -> ${firstChildNodeIdx}`,\n                );\n                nearestNodeRange.extendEndNodeIdx(Number(firstChildNodeIdx));\n                continue;\n            }\n\n            const newNodeRange: NodeRange = (() => {\n                const level = nodeRange.level() - 1;\n                const range: [number, number] = [Number(firstChildNodeIdx), Number(firstChildNodeIdx) + 1];\n                return new NodeRange(range, level);\n            })();\n\n            // We're going to add a new node range - log the reason\n            if (nearestNodeRange !== undefined && nearestNodeRange.level() === newNodeRange.level()) {\n                console.debug(\n                    `Same level, but too far away. Pushing new request for nodeIdx: ${firstChildNodeIdx} rather than merging with distant ${nearestNodeRange}`,\n                );\n            } else {\n                console.debug(\n                    `Pushing new level for ${newNodeRange} onto queue with nearestNodeRange: ${nearestNodeRange} since there's not already a range for this level.`,\n                );\n            }\n\n            queue.push(newNodeRange);\n        }\n    }\n}\n"],"names":["Config","NODE_ITEM_BYTE_LEN","NODE_ITEM_LEN","DEFAULT_NODE_SIZE","calcTreeSize","numItems","nodeSize","Math","min","max","n","numNodes","ceil","generateLevelBounds","Error","levelNumNodes","push","levelOffsets","size","levelBounds","i","length","streamSearch","rect","readNode","NodeRange","_level","nodes","level","startNodeIdx","endNodeIdx","extendEndNodeIdx","newIdx","toString","minX","minY","maxX","maxY","firstLeafNodeIdx","queue","nodeRange","shift","nodeRangeStartIdx","isLeafNode","nodeRangeEndIdx","levelBound","nodeIdx","numNodesInRange","dataView","DataView","nodeIdxInDataView","dataViewByteStart","getFloat64","offset","getBigUint64","featureLength","nextPos","nextOffset","featureIdx","Number","extraRequestThresholdNodes","global","extraRequestThreshold","nearestNodeRange","undefined","firstChildNodeIdx","newNodeRange"],"mappings":"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"}