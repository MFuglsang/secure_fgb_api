import{magicbytes as e}from"../constants.js";import{buildFeature as t}from"../generic/feature.js";import{buildHeader as r,deserialize as n,deserializeFiltered as i,deserializeStream as l,mapColumn as o}from"../generic/featurecollection.js";import{inferGeometryType as s}from"../generic/header.js";import{fromFeature as a}from"./feature.js";import{parseGC as u,parseGeometry as m}from"./geometry.js";export function serialize(n,i=0){let l=function(e){let t=e.features[0].properties,r=null;return t&&(r=Object.keys(t).map(e=>o(t,e))),{geometryType:s(e.features),columns:r,envelope:null,featuresCount:e.features.length,indexNodeSize:0,crs:null,title:null,description:null,metadata:null}}(n),a=r(l,i),f=n.features.map(e=>t("GeometryCollection"===e.geometry.type?u(e.geometry):m(e.geometry),e.properties,l)),p=f.map(e=>e.length).reduce((e,t)=>e+t),c=new Uint8Array(e.length+a.length+p);c.set(a,e.length);let g=e.length+a.length;for(let e of f)c.set(e,g),g+=e.length;return c.set(e),c}export async function*deserialize(e,t,r){yield*n(e,a,t,r)}export function deserializeStream(e,t){return l(e,a,t)}export function deserializeFiltered(e,t,r,n=!1,l={}){return i(e,t,a,r,n,l)}
//# sourceMappingURL=featurecollection.js.map