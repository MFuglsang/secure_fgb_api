{"version":3,"sources":["../../../../../src/ts/geojson/featurecollection.ts"],"sourcesContent":["import type {\n    FeatureCollection as GeoJsonFeatureCollection,\n    GeometryCollection,\n    LineString,\n    MultiLineString,\n    MultiPoint,\n    MultiPolygon,\n    Point,\n    Polygon,\n} from 'geojson';\nimport type { ColumnMeta } from '../column-meta.js';\n\nimport { magicbytes } from '../constants.js';\nimport { buildFeature, type IFeature, type IProperties } from '../generic/feature.js';\nimport {\n    buildHeader,\n    deserialize as genericDeserialize,\n    deserializeFiltered as genericDeserializeFiltered,\n    deserializeStream as genericDeserializeStream,\n    mapColumn,\n} from '../generic/featurecollection.js';\nimport { inferGeometryType } from '../generic/header.js';\nimport type { HeaderMetaFn } from '../generic.js';\nimport type { HeaderMeta } from '../header-meta.js';\nimport type { Rect } from '../packedrtree.js';\nimport { fromFeature } from './feature.js';\nimport { parseGC, parseGeometry } from './geometry.js';\n\nexport function serialize(featurecollection: GeoJsonFeatureCollection, crsCode = 0): Uint8Array {\n    const headerMeta = introspectHeaderMeta(featurecollection);\n    const header = buildHeader(headerMeta, crsCode);\n    const features: Uint8Array[] = featurecollection.features.map((f) =>\n        buildFeature(\n            f.geometry.type === 'GeometryCollection'\n                ? parseGC(f.geometry as GeometryCollection)\n                : parseGeometry(\n                      f.geometry as Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon,\n                  ),\n            f.properties as IProperties,\n            headerMeta,\n        ),\n    );\n    const featuresLength = features.map((f) => f.length).reduce((a, b) => a + b);\n    const uint8 = new Uint8Array(magicbytes.length + header.length + featuresLength);\n    uint8.set(header, magicbytes.length);\n    let offset = magicbytes.length + header.length;\n    for (const feature of features) {\n        uint8.set(feature, offset);\n        offset += feature.length;\n    }\n    uint8.set(magicbytes);\n    return uint8;\n}\n\nexport async function* deserialize(\n    bytes: Uint8Array,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n): AsyncGenerator<IFeature> {\n    yield* genericDeserialize(bytes, fromFeature, rect, headerMetaFn);\n}\n\nexport function deserializeStream(stream: ReadableStream, headerMetaFn?: HeaderMetaFn): AsyncGenerator<IFeature> {\n    return genericDeserializeStream(stream, fromFeature, headerMetaFn);\n}\n\nexport function deserializeFiltered(\n    url: string,\n    rect: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache = false,\n    headers: HeadersInit = {},\n): AsyncGenerator<IFeature> {\n    return genericDeserializeFiltered(url, rect, fromFeature, headerMetaFn, nocache, headers);\n}\n\nfunction introspectHeaderMeta(featurecollection: GeoJsonFeatureCollection): HeaderMeta {\n    const feature = featurecollection.features[0];\n    const properties = feature.properties;\n\n    let columns: ColumnMeta[] | null = null;\n    if (properties) columns = Object.keys(properties).map((k) => mapColumn(properties, k));\n\n    const geometryType = inferGeometryType(featurecollection.features);\n    const headerMeta: HeaderMeta = {\n        geometryType,\n        columns,\n        envelope: null,\n        featuresCount: featurecollection.features.length,\n        indexNodeSize: 0,\n        crs: null,\n        title: null,\n        description: null,\n        metadata: null,\n    };\n\n    return headerMeta;\n}\n"],"names":["magicbytes","buildFeature","buildHeader","deserialize","genericDeserialize","deserializeFiltered","genericDeserializeFiltered","deserializeStream","genericDeserializeStream","mapColumn","inferGeometryType","fromFeature","parseGC","parseGeometry","serialize","featurecollection","crsCode","headerMeta","introspectHeaderMeta","properties","feature","features","columns","Object","keys","map","k","geometryType","envelope","featuresCount","length","indexNodeSize","crs","title","description","metadata","header","f","geometry","type","featuresLength","reduce","a","b","uint8","Uint8Array","set","offset","bytes","rect","headerMetaFn","stream","url","nocache","headers"],"mappings":"AAYA,OAASA,cAAAA,CAAU,KAAQ,iBAAkB,AAC7C,QAASC,gBAAAA,CAAY,KAAyC,uBAAwB,AACtF,QACIC,eAAAA,CAAW,CACXC,eAAeC,CAAkB,CACjCC,uBAAuBC,CAA0B,CACjDC,qBAAqBC,CAAwB,CAC7CC,aAAAA,CAAS,KACN,iCAAkC,AACzC,QAASC,qBAAAA,CAAiB,KAAQ,sBAAuB,AAIzD,QAASC,eAAAA,CAAW,KAAQ,cAAe,AAC3C,QAASC,WAAAA,CAAO,CAAEC,iBAAAA,CAAa,KAAQ,eAAgB,AAEvD,QAAO,SAASC,UAAUC,CAA2C,CAAEC,EAAU,CAAC,EAC9E,IAAMC,EAAaC,AA+CvB,SAA8BH,CAA2C,EAErE,IAAMI,EAAaC,AADHL,EAAkBM,QAAQ,CAAC,EAAE,CAClBF,UAAU,CAEjCG,EAA+B,KAgBnC,OAfIH,GAAYG,CAAAA,EAAUC,OAAOC,IAAI,CAACL,GAAYM,GAAG,CAAC,AAACC,GAAMjB,EAAUU,EAAYO,GAAE,EAGtD,CAC3BC,aAFiBjB,EAAkBK,EAAkBM,QAAQ,EAG7DC,QAAAA,EACAM,SAAU,KACVC,cAAed,EAAkBM,QAAQ,CAACS,MAAM,CAChDC,cAAe,EACfC,IAAK,KACLC,MAAO,KACPC,YAAa,KACbC,SAAU,IACd,CAGJ,EApE4CpB,GAClCqB,EAASlC,EAAYe,EAAYD,GACjCK,EAAyBN,EAAkBM,QAAQ,CAACI,GAAG,CAAC,AAACY,GAC3DpC,EACIoC,AAAoB,uBAApBA,EAAEC,QAAQ,CAACC,IAAI,CACT3B,EAAQyB,EAAEC,QAAQ,EAClBzB,EACIwB,EAAEC,QAAQ,EAEpBD,EAAElB,UAAU,CACZF,IAGFuB,EAAiBnB,EAASI,GAAG,CAAC,AAACY,GAAMA,EAAEP,MAAM,EAAEW,MAAM,CAAC,CAACC,EAAGC,IAAMD,EAAIC,GACpEC,EAAQ,IAAIC,WAAW7C,EAAW8B,MAAM,CAAGM,EAAON,MAAM,CAAGU,GACjEI,EAAME,GAAG,CAACV,EAAQpC,EAAW8B,MAAM,EACnC,IAAIiB,EAAS/C,EAAW8B,MAAM,CAAGM,EAAON,MAAM,CAC9C,IAAK,IAAMV,KAAWC,EAClBuB,EAAME,GAAG,CAAC1B,EAAS2B,GACnBA,GAAU3B,EAAQU,MAAM,CAG5B,OADAc,EAAME,GAAG,CAAC9C,GACH4C,CACX,CAEA,OAAO,eAAgBzC,YACnB6C,CAAiB,CACjBC,CAAW,CACXC,CAA2B,EAE3B,MAAO9C,EAAmB4C,EAAOrC,EAAasC,EAAMC,EACxD,CAEA,OAAO,SAAS3C,kBAAkB4C,CAAsB,CAAED,CAA2B,EACjF,OAAO1C,EAAyB2C,EAAQxC,EAAauC,EACzD,CAEA,OAAO,SAAS7C,oBACZ+C,CAAW,CACXH,CAAU,CACVC,CAA2B,CAC3BG,EAAU,CAAA,CAAK,CACfC,EAAuB,CAAC,CAAC,EAEzB,OAAOhD,EAA2B8C,EAAKH,EAAMtC,EAAauC,EAAcG,EAASC,EACrF"}