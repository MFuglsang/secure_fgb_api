import{GeometryType as e}from"../flat-geobuf/geometry-type.js";import{flat as t,pairFlatCoordinates as r,toGeometryType as o}from"../generic/geometry.js";export function parseGeometry(e){let r,n,i=e.coordinates,a=[],l=[],p=o(e.type),s=0;switch(e.type){case"Point":case"MultiPoint":case"LineString":t(i,a,l);break;case"MultiLineString":case"Polygon":t(i,a,l),i.length>1&&(r=i.map(e=>s+=e.length));break;case"MultiPolygon":n=i.map(e=>({type:"Polygon",coordinates:e})).map(parseGeometry)}return{xy:a,z:l.length>0?l:void 0,ends:r,type:p,parts:n}}export function parseGC(e){let t=o(e.type),r=[];for(let t=0;t<e.geometries.length;t++){let o=e.geometries[t];"GeometryCollection"===o.type?r.push(parseGC(o)):r.push(parseGeometry(o))}return{type:t,parts:r}}export function fromGeometry(t,o){let n=o;if(n===e.Unknown&&(n=t.type()),n===e.GeometryCollection){let r=[];for(let e=0;e<t.partsLength();e++){let o=t.parts(e),n=o.type();r.push(fromGeometry(o,n))}return{type:e[n],geometries:r}}if(n===e.MultiPolygon){let r=[];for(let o=0;o<t.partsLength();o++)r.push(fromGeometry(t.parts(o),e.Polygon));return{type:e[n],coordinates:r.map(e=>e.coordinates)}}let i=function(t,o){let n=t.xyArray(),i=t.zArray();switch(o){case e.Point:{let e=Array.from(n);return i&&e.push(i[0]),e}case e.MultiPoint:case e.LineString:return r(n,i);case e.MultiLineString:case e.Polygon:return function(e,t,o){let n;if(!o||0===o.length)return[r(e,t)];let i=0,a=Array.from(o).map(t=>e.slice(i,i=t<<1));return t&&(i=0,n=Array.from(o).map(e=>t.slice(i,i=e))),a.map((e,t)=>r(e,n?n[t]:void 0))}(n,i,t.endsArray())}}(t,n);return{type:e[n],coordinates:i}}
//# sourceMappingURL=geometry.js.map