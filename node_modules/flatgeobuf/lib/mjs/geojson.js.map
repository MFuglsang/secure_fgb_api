{"version":3,"sources":["../../../../src/ts/geojson.ts"],"sourcesContent":["import type { FeatureCollection as GeoJsonFeatureCollection } from 'geojson';\nimport type { HeaderMetaFn } from './generic.js';\nimport type { IGeoJsonFeature } from './geojson/feature.js';\nimport {\n    deserialize as fcDeserialize,\n    deserializeFiltered as fcDeserializeFiltered,\n    deserializeStream as fcDeserializeStream,\n    serialize as fcSerialize,\n} from './geojson/featurecollection.js';\nimport type { Rect } from './packedrtree.js';\n\n/**\n * Serialize GeoJSON to FlatGeobuf\n * @param geojson GeoJSON object to serialize\n */\nexport function serialize(geojson: GeoJsonFeatureCollection, crsCode = 0): Uint8Array {\n    const bytes = fcSerialize(geojson, crsCode);\n    return bytes;\n}\n\n/**\n * Deserialize FlatGeobuf into GeoJSON features\n * @param url Input string\n * @param rect Filter rectangle - NOT USED\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    url: string,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n    headers?: HeadersInit,\n): AsyncGenerator<IGeoJsonFeature>;\n\n/**\n * Deserialize FlatGeobuf from a typed array into GeoJSON features\n * NOTE: Does not support spatial filtering\n * @param typedArray Input byte array\n * @param rect Filter rectangle - NOT USED\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    typedArray: Uint8Array,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n    headers?: HeadersInit,\n): AsyncGenerator<IGeoJsonFeature>;\n\n/**\n * Deserialize FlatGeobuf from a stream into GeoJSON features\n * NOTE: Does not support spatial filtering\n * @param stream stream\n * @param rect Filter rectangle\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    stream: ReadableStream,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n    headers?: HeadersInit,\n): AsyncGenerator<IGeoJsonFeature>;\n\n/** Implementation */\nexport function deserialize(\n    input: Uint8Array | ReadableStream | string,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache = false,\n    headers: HeadersInit = {},\n): AsyncGenerator<IGeoJsonFeature> {\n    if (input instanceof Uint8Array) return fcDeserialize(input, rect, headerMetaFn) as AsyncGenerator<IGeoJsonFeature>;\n    if (input instanceof ReadableStream)\n        return fcDeserializeStream(input, headerMetaFn) as AsyncGenerator<IGeoJsonFeature>;\n    return fcDeserializeFiltered(input, rect!, headerMetaFn, nocache, headers) as AsyncGenerator<IGeoJsonFeature>;\n}\n"],"names":["deserialize","fcDeserialize","deserializeFiltered","fcDeserializeFiltered","deserializeStream","fcDeserializeStream","serialize","fcSerialize","geojson","crsCode","input","rect","headerMetaFn","nocache","headers","Uint8Array","ReadableStream"],"mappings":"AAGA,OACIA,eAAeC,CAAa,CAC5BC,uBAAuBC,CAAqB,CAC5CC,qBAAqBC,CAAmB,CACxCC,aAAaC,CAAW,KACrB,gCAAiC,AAOxC,QAAO,SAASD,UAAUE,CAAiC,CAAEC,EAAU,CAAC,EAEpE,OADcF,EAAYC,EAASC,EAEvC,CA+CA,OAAO,SAAST,YACZU,CAA2C,CAC3CC,CAAW,CACXC,CAA2B,CAC3BC,EAAU,CAAA,CAAK,CACfC,EAAuB,CAAC,CAAC,SAEzB,AAAIJ,aAAiBK,WAAmBd,EAAcS,EAAOC,EAAMC,GAC/DF,aAAiBM,eACVX,EAAoBK,EAAOE,GAC/BT,EAAsBO,EAAOC,EAAOC,EAAcC,EAASC,EACtE"}