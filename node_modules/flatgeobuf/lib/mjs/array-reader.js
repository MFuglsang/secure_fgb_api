import*as e from"flatbuffers";import{magicbytes as t,SIZE_PREFIX_LEN as r}from"./constants.js";import{Feature as a}from"./flat-geobuf/feature.js";import{fromByteBuffer as s}from"./header-meta.js";import{calcTreeSize as i,streamSearch as n}from"./packedrtree.js";export class ArrayReader{bytes;header;headerLength;indexLength;constructor(e,t,r,a){this.bytes=e,this.header=t,this.headerLength=r,this.indexLength=a}static open(r){if(!r.subarray(0,3).every((e,r)=>t[r]===e))throw Error("Not a FlatGeobuf file");let a=new DataView(r.buffer).getUint32(8,!0);if(a>0xa00000||a<8)throw Error("Invalid header size");let n=r.subarray(12,12+a),h=s(new e.ByteBuffer(n)),o=i(h.featuresCount,h.indexNodeSize);return new ArrayReader(r,h,a,o)}async *selectBbox(e){let t=this.lengthBeforeTree(),r=async(e,r)=>{let a=t+e;return this.bytes.slice(a,a+r).buffer};for await(let t of n(this.header.featuresCount,this.header.indexNodeSize,e,r)){let[e,r]=t,a=this.readFeature(e);yield{id:r,feature:a}}}lengthBeforeTree(){return t.length+r+this.headerLength}lengthBeforeFeatures(){return this.lengthBeforeTree()+this.indexLength}readFeature(t){let s=t+this.lengthBeforeFeatures(),i=new DataView(this.bytes.buffer).getUint32(s,!0),n=this.bytes.subarray(s+4,s+4+i),h=new Uint8Array(i+r);h.set(n,r);let o=new e.ByteBuffer(h);return o.setPosition(r),a.getRootAsFeature(o)}}
//# sourceMappingURL=array-reader.js.map