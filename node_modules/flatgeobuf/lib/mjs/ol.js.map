{"version":3,"sources":["../../../../src/ts/ol.ts"],"sourcesContent":["import type { Extent } from 'ol/extent.js';\nimport type Feature from 'ol/Feature.js';\nimport type { FeatureLike } from 'ol/Feature.js';\nimport type { FeatureLoader } from 'ol/featureloader.js';\nimport { all } from 'ol/loadingstrategy.js';\nimport type VectorSource from 'ol/source/Vector.js';\nimport type { LoadingStrategy } from 'ol/source/Vector.js';\nimport type { LoadFunction } from 'ol/Tile.js';\nimport type { TileCoord } from 'ol/tilecoord.js';\nimport type VectorTile from 'ol/VectorTile.js';\nimport type { IFeature } from './generic/feature.js';\n\nimport { FeatureCollection, type FeatureCollectionOptions } from './ol/featurecollection.js';\nimport type { Rect } from './packedrtree.js';\n\nexport { FeatureCollection };\nexport type { FeatureCollectionOptions };\n\n/**\n * Serialize OpenLayers Features to FlatGeobuf\n * @param fc Features to serialize\n * @param features Features to serialize\n */\nexport function serialize(fc: FeatureCollection, features: Feature[]): Uint8Array {\n    return fc.serialize(features as IFeature[]);\n}\n\n/**\n * Deserialize FlatGeobuf into OpenLayers Features\n * @param fc\n * @param input Input byte array, stream or string\n * @param rect Filter rectangle\n */\nexport function deserialize(\n    fc: FeatureCollection,\n    input: Uint8Array | ReadableStream | string,\n    rect?: Rect,\n): AsyncGenerator<FeatureLike> {\n    if (input instanceof Uint8Array) return fc.deserialize(input) as AsyncGenerator<FeatureLike>;\n    if (input instanceof ReadableStream) return fc.deserializeStream(input) as AsyncGenerator<FeatureLike>;\n    return fc.deserializeFiltered(input, rect!) as AsyncGenerator<FeatureLike>;\n}\n\nasync function createIterator(url: string, extent: Extent, strategy: LoadingStrategy, fc: FeatureCollection) {\n    if (strategy === all) {\n        const headers = fc.getHeaders();\n        const response = await fetch(url, { headers });\n        return deserialize(fc, response.body as ReadableStream);\n    }\n    const rect = fc.getRect(extent);\n    return deserialize(fc, url, rect);\n}\n\n/**\n * Intended to be used with VectorSource and setLoader to set up\n * a single file FlatGeobuf as a source.\n * @param fc\n * @param source\n * @param url\n * @param strategy\n * @param clear\n * @returns\n */\nexport function createLoader(\n    fc: FeatureCollection,\n    source: VectorSource<FeatureLike>,\n    url: string,\n    strategy: LoadingStrategy = all,\n    clear = false,\n): FeatureLoader<FeatureLike> {\n    return async (extent, _resolution, _projection, success, failure) => {\n        try {\n            if (clear) source.clear();\n            const it = await createIterator(url, extent, strategy, fc);\n            const features: FeatureLike[] = [];\n            for await (const feature of it) {\n                features.push(feature);\n                source.addFeature(feature);\n            }\n            success?.(features);\n        } catch (e) {\n            console.error(e);\n            failure?.();\n        }\n    };\n}\n\n/**\n * Intended to be used with VectorTileSource as pseudo URL to key requests.\n * @param tileCoord\n * @returns\n */\nexport const tileUrlFunction = (tileCoord: TileCoord) => JSON.stringify(tileCoord);\n\n/**\n * Intended to be used with VectorTileSource and setTileLoadFunction to set up\n * a single file FlatGeobuf as a source.\n * @param fc\n * @param url\n * @returns\n */\nexport function createTileLoadFunction(fc: FeatureCollection, url: string) {\n    const tileLoadFunction: LoadFunction = (tile) => {\n        const vectorTile = tile as VectorTile<FeatureLike>;\n        const loader: FeatureLoader = async (extent) => {\n            const rect = fc.getRect(extent);\n            const it = deserialize(fc, url, rect);\n            const features: FeatureLike[] = [];\n            for await (const feature of it) features.push(feature);\n            vectorTile.setFeatures(features);\n        };\n        vectorTile.setLoader(loader);\n    };\n    return tileLoadFunction;\n}\n"],"names":["all","FeatureCollection","serialize","fc","features","deserialize","input","rect","Uint8Array","ReadableStream","deserializeStream","deserializeFiltered","createIterator","url","extent","strategy","headers","getHeaders","response","fetch","body","getRect","createLoader","source","clear","_resolution","_projection","success","failure","it","feature","push","addFeature","e","tileUrlFunction","tileCoord","JSON","stringify","createTileLoadFunction","tile","loader","vectorTile","setFeatures","setLoader"],"mappings":"AAIA,OAASA,OAAAA,CAAG,KAAQ,uBAAwB,AAQ5C,QAASC,qBAAAA,CAAiB,KAAuC,2BAA4B,AAW7F,QAAO,SAASC,UAAUC,CAAqB,CAAEC,CAAmB,EAChE,OAAOD,EAAGD,SAAS,CAACE,EACxB,CAQA,OAAO,SAASC,YACZF,CAAqB,CACrBG,CAA2C,CAC3CC,CAAW,SAEX,AAAID,aAAiBE,WAAmBL,EAAGE,WAAW,CAACC,GACnDA,aAAiBG,eAAuBN,EAAGO,iBAAiB,CAACJ,GAC1DH,EAAGQ,mBAAmB,CAACL,EAAOC,EACzC,CAEA,eAAeK,EAAeC,CAAW,CAAEC,CAAc,CAAEC,CAAyB,CAAEZ,CAAqB,EACvG,GAAIY,IAAaf,EAAK,CAClB,IAAMgB,EAAUb,EAAGc,UAAU,GAE7B,OAAOZ,YAAYF,EAAIe,AADN,CAAA,MAAMC,MAAMN,EAAK,CAAEG,QAAAA,CAAQ,EAAC,EACbI,IAAI,CACxC,CACA,IAAMb,EAAOJ,EAAGkB,OAAO,CAACP,GACxB,OAAOT,YAAYF,EAAIU,EAAKN,EAChC,CAYA,OAAO,SAASe,aACZnB,CAAqB,CACrBoB,CAAiC,CACjCV,CAAW,CACXE,EAA4Bf,CAAG,CAC/BwB,EAAQ,CAAA,CAAK,EAEb,OAAO,MAAOV,EAAQW,EAAaC,EAAaC,EAASC,KACrD,GAAI,CACIJ,GAAOD,EAAOC,KAAK,GACvB,IAAMK,EAAK,MAAMjB,EAAeC,EAAKC,EAAQC,EAAUZ,GACjDC,EAA0B,EAAE,CAClC,UAAW,IAAM0B,KAAWD,EACxBzB,EAAS2B,IAAI,CAACD,GACdP,EAAOS,UAAU,CAACF,GAEtBH,IAAUvB,EACd,CAAE,MAAO6B,EAAG,CAERL,KACJ,CACJ,CACJ,CAOA,OAAO,MAAMM,gBAAkB,AAACC,GAAyBC,KAAKC,SAAS,CAACF,EAAW,AASnF,QAAO,SAASG,uBAAuBnC,CAAqB,CAAEU,CAAW,EAYrE,OAXuC,AAAC0B,IAEpC,IAAMC,EAAwB,MAAO1B,IACjC,IAAMP,EAAOJ,EAAGkB,OAAO,CAACP,GAClBe,EAAKxB,YAAYF,EAAIU,EAAKN,GAC1BH,EAA0B,EAAE,CAClC,UAAW,IAAM0B,KAAWD,EAAIzB,EAAS2B,IAAI,CAACD,GAC9CW,AANeF,EAMJG,WAAW,CAACtC,EAC3B,EACAqC,AARmBF,EAQRI,SAAS,CAACH,EACzB,CAEJ,QAnGSvC,KAAAA,iBAAiB"}